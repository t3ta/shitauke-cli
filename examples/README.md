# shitauke-cli Examples

## 概要

このディレクトリには、`shitauke-cli` を使用した様々なユースケースの例が含まれています。各例は「入力→処理→出力」の一連の流れを示し、AIモデルへの効果的な発注方法を学ぶための参考になります。

## 例の追加・整理ガイドライン

### 基本原則

1. **アトミックな設計**: 各例は「1つの入力に対して1つの出力」という原則に従い、単一の明確なタスクを示す
2. **自己完結性**: 各例は依存関係なく単独で機能し、必要な情報がすべて含まれている
3. **標準化**: 統一されたディレクトリ構造とファイル命名規則に従う
4. **実行可能性**: 実際にコマンドを実行して動作確認済みの例のみを含める
5. **簡潔さ**: 余分なファイルや処理を含めず、エッセンスだけを示す

### ディレクトリ構造

各例は以下のディレクトリ構造に従います：

```
examples/
├── example-name/
│   ├── README.md        # 使用方法の説明
│   ├── optimal-prompt.txt  # 最適化されたプロンプト
│   ├── input.*          # 入力ファイル (sample.md, api_spec.json など)
│   └── output.*         # 出力ファイル (output.json, api-client.ts など)
```

### ファイル説明

#### README.md

各例のREADME.mdには以下の内容を含めます：

1. **概要**: 例の目的と特徴を簡潔に説明
2. **使用方法**: 実行コマンドの例（基本的な使い方、上書きオプション、テンプレート利用など）
3. **プロンプト最適化のポイント**: プロンプトの工夫点
4. **入力/出力の説明**: 入力ファイルと出力ファイルの内容説明
5. **ファイル構成**: 含まれるファイルの一覧と役割
6. **ユースケース**: この例が役立つシナリオ
7. **（オプション）拡張アイデア**: さらなる改善や応用方法

#### optimal-prompt.txt

最適化されたプロンプトファイルには以下の特徴を持たせます：

1. **明確な指示**: AI モデルへの明確で具体的な指示
2. **構造化**: セクションや見出しで整理された構造
3. **制約や要件**: 出力形式やフォーマットの指定
4. **例や参考**: 必要に応じてサンプルや参考情報

#### 入力/出力ファイル

- 入力ファイルは実際のユースケースに基づいた現実的なデータを含める
- 出力ファイルは実際にコマンドを実行して生成された結果を含める
- 出力ファイルの形式は対象に合わせて適切に設定（`-f` オプションの指定）
  - JSONデータの場合は `.json` かつ `-f json`
  - Markdownの場合は `.md` かつ `-f markdown`
  - TypeScriptコードの場合は `.ts` かつ `-f ts` (マークダウンブロックなし)
  - プレーンテキストの場合は `.txt` かつ `-f text`

### 例の追加手順

1. **概念設計**:
   - 解決すべき問題やユースケースを明確にする
   - 入力と期待される出力を定義する

2. **ディレクトリ作成**:
   ```bash
   mkdir -p examples/new-example-name
   ```

3. **入力ファイル作成**:
   - 実際のユースケースに基づいたテストデータを用意
   - 適切な形式で保存（JSON, Markdown, テキストなど）

4. **プロンプト作成**:
   - 目的に合わせた最適なプロンプトを作成
   - セクションや構造で整理し、明確な指示を含める
   - `optimal-prompt.txt` として保存

5. **実行テスト**:
   ```bash
   # ビルド
   cd /Users/tmita/workspace/shitauke-cli && npm run build
   
   # 実行
   node dist/index.js send "$(cat ./examples/new-example-name/optimal-prompt.txt)" \
     -m gemini-2.0-flash-001 \
     -f <format> \
     -i ./examples/new-example-name/input.* \
     -o ./examples/new-example-name/output.* \
     --overwrite
   ```

6. **README作成**:
   - 上記のテンプレートに従ってREADME.mdを作成
   - 使用方法や特徴を明確に説明

7. **コードフォーマット問題の対応**:
   - TypeScriptなどのコード出力時は `-f ts` オプションを使用
   - マークダウンブロックが含まれる場合は、プロンプトに「コードブロック記法を含めない」という指示を追加

### 既存の例の修正・整理手順

1. **現状確認**:
   - ディレクトリ構造とファイル内容を確認
   - 問題点を特定（複数出力、冗長なファイル、マークダウンコードブロックなど）

2. **プロンプト修正**:
   - 単一出力に焦点を当てたプロンプトに修正
   - コード出力の場合は「コードブロック記法を含めない」という指示を追加

3. **出力テスト**:
   - 修正したプロンプトでコマンドを実行
   - 出力結果が期待通りか確認

4. **ファイル整理**:
   - 不要なファイルを削除または別ディレクトリに移動
   - 必要なファイルのみを残す

5. **README更新**:
   - 変更点を反映したREADME.mdを更新

### 注意事項

- **出力フォーマット**: 特にコード出力時は適切な `-f` オプションを指定する（例: `-f ts` でTypeScriptコード生成）
- **ファイル名**: わかりやすく一貫性のあるファイル名を使用する
- **テスト確認**: 追加・修正した例は必ず実行してテストする
- **大きすぎる出力**: 大きなコードベースや複雑な出力が必要な場合は、範囲を限定するか複数の例に分割する
- **シンプルさ**: 必要最小限のファイルのみを含め、余計な複雑さを避ける

## 既存の例

| 例名 | 説明 | 入力 | 出力 | モデル |
|------|------|------|------|-------|
| markdown-to-json | マークダウンをJSON構造に変換 | sample.md | output.json | gemini-2.0-flash-001 |
| api-client-generator | API仕様からTypeScriptクライアントを生成 | api_spec.json | api-client.ts | gemini-2.0-flash-001 |
| （今後追加） | ... | ... | ... | ... |

